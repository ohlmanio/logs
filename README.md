# Useful Logs
Take control over your app's logging output.

**Work in Progress - Not all documented features have been implemented!**

**Features**

1. Log format is structured - we use bunyan under the hood to output JSON formatted logs
2. Log output is streamed to any listeners you setup
3. Log input is extensible, you can easily flag log messages with indicators such as the current method/subscription, userId, or any other info that's available to your app.


## Gettign Started

Add the useful:logs package:
```
meteor add useful:logs
```

This makes the `Log` global available with the following methods:

`Log.info(message)` - Use this for general logging output that might be useful in debugging errors or other issues
`Log.trace`, `Log.debug` - Use for more verbose logging, see bynan docs for more info
`Log.warn`, `Log.error`, `Log.fatal` - Use for more critical logging, see bunyan docs for more info
`Log.child(options)` - Create & return a child logger which will emit messages extended by the options object you pass in.
`Log.with(options, fn)` - Like `Log.child` but uses Meteor's `EnvironmentVariable`s to apply the extended options to all calls made via current logger from within fn. See evented mind's videos on Meteor EnvironmentVariables nad Meteor `bindEnvironment` for more info.

Start by just using `Log.info` for your regular logging, e.g. you might already be logging requests to external apis, just replace `console.log` with `Log.info`.

Then start adding (sparingly) relevant info via the first argument to your log statement, for example you might log calls to an external api like this:

```js
try {
  Log.info({
    url: url
  }, 'downloading google maps data');
  var result = HTTP.get(url);
  Log.info({
    url: url
    , resulsLength: result.data.length
  }, 'got google maps data');
} catch (e) {
  Log.error({
    url: url
    , err: e
  }, 'could not get google maps data');
}
```

This will helpfully include the url, and other relevenat data to your logging output, without cluttering up the log message.

Next start using `Log.child` and `Log.with`. Here's an example of how you could greatly improve the quality of logs generated by a meteor method:

```js
Meteor.methods({
  signUpForService: function (serviceLevel) {
    Log.with({
      meteorMethod: 'signUpForService'
      , serviceLevel: serviceLevel
      , userId: Meteor.userId()
      , meteorMethodCallId: Random.id()
    }, function () {
      // Here for demonstration we're going to be very verbose in our logging,
      // in reality this level of detail is probably not necessary
      Log.trace('signing user up for service: %s', serviceLevel);
      
      Log.trace('charging user for service: %s', serviceLevel);
      Payments.chargeForService(Meteor.userId(), serviceLevel);
      
      Log.trace('updating user roles for service: %s', serviceLevel);
      Services.upgradeUser(Meteor.userId(), serviceLevel);
    });
  }
});
```

Notice above that we call several external methods `Payments.chargeForService` and `Services.upgradeUser`, any `Log.*` methods called by those methods will be extended with the options we passed to `Log.with`, so that all logs related to this method call will include the `meteorMethod` & `meteorMethodCallId` which will make it easy to filter out log messages to show only the logs related to this individual method call.

A really handy use of the `Log.child` method is to create child loggers that you can use inside of a package, or component to ensure that logs comming from that part of your app are labeled as such:

```js
Services = {
  _logger: Log.child({ 'component': 'services' })
  , upgradeUser: function (userId, serviceLevel) {
    var result = Meteor.users.update(userId, {
      serviceLevel: serviceLevel
    });
    // this call to .info will include 'component': 'services', as well any
    // properties passed via Log.with
    this._logger.info({
      userId: userId
      , serviceLevel: serviceLevel
    }, 'upgraded user to new service level');
  }
}
```

<!-- XXX -->

For quick & easy configuration of your log output, add the standard-config package:
```
meteor add useful:logs-standard-config
```

The standard config package provides some default options and output streams for your app:

1. Pretty prints info & more critical messages to your console
2. Stores all log messages in the db
3. Adds bunyan's default serializers

If you want useful:logs to integrate more aggressively with existing log output you can add the standard-hooks package:
```
meteor add useful:logs-standard-hooks
```

This will improve your logging output by:

1. Hijacking `console.log`
2. Wrapping Meteor methods & subscriptions in `Log.with`

<!-- /XXX -->
